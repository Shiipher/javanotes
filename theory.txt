java
->platform independent
portability->write once and run anywhere
3 main components->jvm,jre,jdk
jvm-java virtual machine
java program(platform independent)-compiler-bytecode-jvm-machine code-cpu-output

jvm is platform dependent(jit compiler (just in time compiler))
jre-(java runtime environment) it has-jvm+class libraries
jdk(java development kit)

ques->why in a java file we can have a single public class
jvm needs it that is why there is a restriction
1.main method inside public class
2.public class name should be same as file name
variables
1.primitive-char(2 bytes),byte(1 byte,default-0,signed),
    short(),int,long,float,double,boolean
2.reference/non-primitive-class,interface,array,string,enum etc

->widening/automatic->whenever lower to higher data type going
->down casting->non-automatic
->promotion addition of two smaller same data types leads to higher data type

how float and double are stored in the memory

->reference data type(non-primitive)
no concept of pass by reference or pointers

string->(string literals and string objects)

wrapper classes ->1.autoboxing->conversion of primitive data type to reference {wrapper class}
                  2.unboxing->opposite of it
static
static method can access only access static variables
no use of super
final

method ->perform some task
access specifiers-public,private,protected,default
types of method->system defined,user defined , overloaded , overridden,static method(it is compile time)
final method
abstract method->always inside abstract class,implementation in child class
vararible parameters ->int ....

constructors->it is used to create an instance
also used to initialize the instance var
it can not be static,final,abstract,synchronized,inherited
can not have any return type
why same name as class->for easeness
return type is class->implecitly

java memory management
2 types of memory -1.stack 2.heap
both are created by jvm and stored in RAM
heap has more memory than stack
----stack---
it store temp var and separate memory block for method
primitive data types are stored
store reference of the heap objects(objects with new keyword)
types-1.strong reference(stack have a ref of object in heap (garbage collector does not work on it))
2.weak reference
each thread has its own stack memory
varaible in scope ->in stack
out of the scope ->not in stack
stack full error->java lang stackoverflowerror

-----heap-----
division -1..young generation-division->1.eden(new object enters) 2.s0(age of each is 1 after first sweep left ones enters(minor gc))
                                            3.s1(age of each is 2 after second sweep left ones enters(minor gc))
 2. old generation(after threshold the object gets promoted to it(major gc))
3.non heap(metaspace(permanent generation))(class variables(with static), constant are stored)

garbage collector->mark and sweep algo
                 ->mark and sweep with compact memory
versions of gc->1.serial gc(single thread used) 2.parallel gc(default in java 8) 3.concurrent mark and sweep(cms) 4.gi garbage

types of classes
1.concrete class
2.abstract class
3.super class and sub class
4.object class
5.nested class
    -inner class(non static nested class)
    -anonymous inner class
    -member inner class
    -local inner class
    -static nested class/static class
6.generic class
7.pojo class
8.enum class
9.final class
10.singleton class
11.immutable class
12.wrapper class


















before spring or spring boot
->study servlet and servlet container
servlet is a java class which handles client request process it and return the response
servlet conatiner manages the servlets 
more than one servlet can be there
each servlet can have many functions like doget dopost etc
web.xml is the problem 

web.xml-->
it contains the servlet mappings like customer hits some api and that is to mapped to some servlet 
eg->
/demoservlet/firstendpoint   this api is mapped to servlet 1 in the web.xml code


input reques--> tomcat(servlet container)(application is deplyoed here)-->use the web.xml to determine which servlet has to be called
-->invokes particular servlet-->response-->tomcat-->response

spring solves the problems-->
1.removal of web.xml->web.xml becoms too big and diffcult to manages->spring framework introduce annotations based configurations

2.inversion of control(ioc)->it is more felxible way to manage object dependencies and its lifecycle(through dependecy injection)
@component - tells spriong that you have to amange ethis class or bean
@autowired - tells spring to resolve and add this object dependecy
during runtime a object will be created and will perform functions

3.unit testing is hard

4.difficult to manage rest api

other areas where spring makes life easy for developer is integration with certain tech like hibernate

input->servlet container(tomcat)(our application)->dispatcherservlet->choose the controller ->uses handlermapping
                                                                    ->create an innstance->ioc
                                                                    ->invokes controller method->respective api get invoked
                                                                    ->response

@enablewebmvc->loads all the depedency

pom.xml

configurations class

dispatcher servlet class

spring boot solves challengs with spring
1.depedency management(pom.xml)->no need for adding different dependencies separately and also their versions

2.auto configuration ->no need for separately running dispatcherservlet , appconfig , enablewebmvc , componentmvc
,componentscan . spring boot add internally by default

3.embedded server->no need to create war
    in traditional spring mvc application we need to build a war file which is a packaged file containing your application classes
    jsp pages , configuration files , dependencies
    then we need to deploy this war file to a servlet container like tomcat
    but in spring boot servlet container is already embedded we dont have to do do all this stuff just run the application thats all

what is spring boot
->it provides a quick way to create a production ready application
->spring based framework
->it support convention over configuration->use default for configuration and if developer dont want to go with convention they can override it 
->it also help to run an application as quick as possible

jar->java archive ->stand alone java application
war->web archive->html , css , js many more

            dto           utility       entity         configuration
             |               |               |                 |
        |----------------------------------------------------------------|
        |                                                                |
client->|->controller------------>service----------->repository layer    |
        |   layer                   layer                       |        |
        | ------------------------------------------------------|--------|
                                                                DB


controller layer-->
    mapping of api parameter to request dto
    hosts the api
    @controller
    @restcontroler

service layer-->business logic

repository layer---->DB

DTO->data transfer object
    client sending data post request
    types-1.request dto
          2.response dto


utility->put anything which is common (helper methods)

entity->@entity sql ki baate(classes which are direct representation of tables)

configuration->application.property files(.env file)


before maven ant was was there
    it required what to do and how to do but in the case of maven only what to do
Maven->its a project management tool
    it uses POM project obejct model

    build lifecycle
    1.validate-project structure
    2.compile-source code
    3.test the code
    4.package compiled code
    5.verify the integrity of package
    6.install the package in local repo
    7.deploy the package in remote repo

    pmd is a source code analyzer
    ->finds unused variable
    ->find unused imports
    ->empty catch block
    ->no usage of object
    ->finds dublicate code

    controllers
    ->@controller->class is responsible for handling incoming http req(separatley write @response body)
    ->@restcontroller->controller+response body
    ->@reponse body->indicates teh http response body     return type
    @requestmapping->mapping of an api

     reflection->it is used toe xamine classes methods feilds interfaces at runtime and also possible to change the behaviour of the class repo
     the class object can be created by 3 ways in it
     1-.forname
     2-.class
     3-.getclass
     it is included in java.lang.reflect





                                                                                                                                    



